分支叫法说明，仓库自己创建的分支叫默认分支master，仓库的第一个分支叫主分支，主分支不一定是默认分支。

分支是对commit的追踪和管理。正常情况下，第一次commit会创建默认分支master，但是也可在第一次commit之前先创建一个其它任意命名的分支，我就这么干过除了证明我们不是个遵守规矩的家伙外没任何其它意义，此后不讨论这种情况。

分支可以近似理解为”一条串联起来的历史提交版本“，当前分支的头版本由HEAD指针定位。

新的分支（非默认分支）可以理解为是其它分支中新分出来的一条历史线。重点是无论有多少条分支，紧邻的两条分支总是有一个分节点，所有的分支都能溯源到同一个点。完整分支的起点都是默认分支master的第一次commit。

在分支上执行版本回退命令后，HEAD的指针指向的是历史版本，HEAD版本之后的版本会被移除这条分支，但是通过未关闭的log命令窗口和reflog命令依然可以恢复到这部分遗弃版本。这里抛出一个疑问，这些遗弃版本何时清理？谁清理？怎么清理？另外如果在HEAD版本之后做了提交，然后又去恢复这些遗弃的版本会发生什么？



分支在整个Git体系中处于什么位置？


各分支间的联系？

主分支master是默认创建的分支，也是所有其它分支的根分支。每一个master的子分支都可以分裂出其它分支，分支分裂的特性向下继承。




# 常用的Git分支命令
查看分支： git branch

创建新分支： git branch <branch_name> 

切换分支： git checkout <branch_name>

创建并切换分支： git checkout -b <branch_name> 

合并分支(当前分支合并目标分支)：git marge <target_branch_name>

删除分支(当前分支非删除分支)：git branch -d <branch_name>



# 思考分支的实际用处
分支就如同存档和备份，可以把它理解为一种危机处理策略。在实际的git使用过程中，不断的创建分支（创建备份或存档），完成阶段性任务后合并分支（更新存档），如若中途发生不可控错误，可以从父分支重新开始（读取存档），删除掉错误分支。

Git分支在使用上十分的快捷，因此在分支上完成工作是Git推荐的方式。

配合“git-flow”,享受分支最佳实践。


# 合并分支导致的冲突
讨论冲突前，需要确认一些事实：
1. 待合并的两条分支一般情况下是在逻辑上紧挨着的，非此等情况另谈。
2. 两条分支中，需要分清两者之间逻辑上的主分支，正常情况下都是主分支合并子分支。（这个主分支在概念上不同于master）
3. 两条分支中，如果版本领先的分支包含另一条分支的全部版本，这种情况不会出现冲突，否则就可能出现冲突。
